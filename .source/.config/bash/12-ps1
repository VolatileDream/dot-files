# this file is for all things related to prompt changes
# Includes things for PS0, PS1, PS2, and PS4.

# Note: do not use \[ and \] for non printing characters (eg escape sequences).
#       Instead use \001 and \002, these work correctly in more situations.

# if we don't have awk, enable fast PS1
[ -x /usr/bin/awk ] || FAST_PS1="yes"

ps_prompt=""
prompt(){
	if [ $# -gt 0 ] ; then
		ps_prompt="$*"
	else
		if [ ${#ps_prompt} -gt 0 ]; then
			echo "[$ps_prompt] "
		fi
	fi
}

prompt-sigil(){
  # VIM is set when the shell is started from inside vim
	[ -n "$VIM" ] && echo -n "[vim] "
	[ "$PATH" != "$BASE_PATH" ] && echo -en "\001\e[0;31m\002*\001\e[m\002"
	echo ">"
}

move-to-ps1() {
  # Problem: we want to go to the beginning of the PS1 string.
  # All we know, is that we're executed as part of PS0: after the
  # command is entered, but before it's executed.
  #
  # We need to reconstruct the number of lines that have been printed based
  # on the prompt & the input provided by the user.

  # Evaluate the PS1 command to get the length. This strips out most of the
  # special characters to get a real length for the prompt. If the prompt
  # were multi-line (which is not the case here) then there should also be
  # a `tail -n 1` here as well.
  readonly prompt=`echo "${PS1@P}" | sed "s/\x01[^\x02]*\x02//g" `

  # Convert the history into a series of line lengths.
  # Convert the line lengths into the number of rendered lines.
  # Output the sum of rendered lines.
  read -d '' linelength_awk <<- EOF
    function ceil(val) {
      return (val == int(val)) ? val : int(val) + 1;
    }
    BEGIN { first=1; sum=0;}
    {
      l=length();
      if (first) {
        first=0;
        # Strip out the history entry text from the line.
        gsub(/^\\\\s*[0-9]*\\\\s*/, "");
        # We have to add the length of the prompt to the first line.
        l=length() + ${#prompt};
      }
      # Lines wrap after $COLUMNS characters.
      lines=ceil(l / $COLUMNS);
      sum += lines;
    }
    END { print(sum);}
EOF
  readonly rows=`HISTTIMEFORMAT= history 1 | gawk -- "$linelength_awk"`
  # Since the input flows down, we have to move up.
  echo -en "\e[${rows}A"

  # Unfortunately, some things modify the PS1 and might move the time spec
  # from the beginning of the prompt. Figure out where it is & move to it.
  readonly prefix="${prompt%%--:--*}"
  if [ ${#prefix} -gt 0 ]; then
    echo -en "\e[${#prefix}C"
  fi
}

if [ -n "${FAST_PS1}" ]; then
    path_bits="\w"
else
    source "$HOME/bin/path-bits"
    path_bits='$(path-bits)'
fi
PS1="--:-- \$(prompt)\u@\h:${path_bits} \$(prompt-sigil) "
PS0="\001\e[s\002\$(move-to-ps1)\A\001\e[u\002"

