#!/bin/bash

# This is a simple event command to process things that happened at specific times,
# it takes in an event through command line arguments, and spits out an event to
# the file $PWD/life.md

if [ $# -eq 0 ]; then
	# exit if we have no args
	echo "Usage: $0 <date> event ..."
	exit 0
fi

FILE="$PWD/life.md"

function ensure-file(){
	if [ ! -f "$FILE" ]; then
		echo "My Life" > "$FILE"
		echo "===============" >> "$FILE"
	fi
}

# given $LINE $FILE $CONTENT
function replace-line(){
	line=$1
	file="$2"
	content="$3"
	# get total lines
	count=`wc -l "$file" | grep -oE '^[0-9]+'`

	head -n $((line-1)) "$file"
	echo $content
	tail -n $((count-line)) "$file"
}

# diagnostic output
#echo $0 $@

# common setup stuff
COM=$0 
ensure-file

# always the same format
DATE="$1" ; shift ; EVENT="$@"

case $COM in
	*event)
		# simple case, echo the line to the file, mostly verbatim.
		echo "- $DATE $EVENT" >> $FILE
		;;
	*event-start)
		# fairly simple, insert the line into the file, but mark it as ongoing
		# once the event has ended, we'll look for the incomplete lines
		echo "- $DATE-~ $EVENT" >> $FILE
		;;
	*event-end)
		# rewrite the entire file just to update a single line. (woo)
		# in theory this command could build a log file of sorts, and then do this
		# work in a single pass, but we'll go for naive, because it's easy.
		END_DATE="$DATE"

		# have to escape spaces
		MATCH=$(cat "$FILE" | grep -En -e "-~ $(echo $EVENT | sed 's/ /\ /g')\$" )
		# check if we got a match
		if [ -z "$MATCH" ]; then
			echo "No matching event found for: '$EVENT' @$END_DATE"
			exit 1
		# TODO check for multiple matches
		fi

		# find the line number for the match
		LINE_NUM=`echo $MATCH | grep -oE '^[0-9]+'`
		# pull out the start date of the match
		START_DATE=`echo $MATCH | sed "s_^[0-9]*:- \([^-]*\)-~.*\\\$_\1_"`

		NEW_LINE="- $START_DATE-$END_DATE $EVENT"

		tmp=`mktemp`
		replace-line $LINE_NUM "$FILE" "$NEW_LINE" > "$tmp"
		mv "$tmp" "$FILE"
		;;
	*)
		echo "NOT FOUND: $COM"
		;;
esac

