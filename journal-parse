#!/bin/bash

# Global variables
NAME="$0"
DIR='.'
OUTPUT_DIR='.'
ENTRY_SEPERATOR='---------------'
# interactive argument for xargs
INTERACT=''
SHELL=`which sh`
ECHO=`which echo`

read -d '' SCRIPT <<- EOF
	BEGIN { date=""; }
	/$ENTRY_SEPERATOR/ {
		gsub( /^$ENTRY_SEPERATOR/, "" );
		date = \$0;
	}
	/^![^ ]*d/ {
		# bump all of the arguments and insert
		# the date as the 1st argument
		gsub( /^![^ ]* +[^ ]+/, "& " date );
	}
	/^!/ {
		# remove the ! and meta chars
		gsub( /^![^ ]* +/, "" );
		print \$0 ;
	}
EOF

function usage(){
	echo "Usage: ${NAME} [-d command-dir] [-o output-dir] [-p] files"
	echo -e "\tParse plain text journal files to generate secondary data sources"
	echo
	echo -e "\t-d command-dir: specificy the directory to find commands. default=."
	echo -e "\t-o output-dir: specificy the directory to output to. default=."
	echo -e "\t-p : get prompted before each command runs."
	echo -e "\tfiles - journal files to parse"
}

function absolute-path(){
	# check the first character
	if [ "${1:0:1}" = "/" ]; then
		echo "$1"
	else
		echo "${PWD}/${1}"
	fi
}

function parse-file(){
	FILE="$(absolute-path "$1")"
	COM="$(absolute-path "$DIR")"
	OUT="$(absolute-path "$OUTPUT_DIR")"
	if [ -f "$1" ]; then
		echo "Parsing: '$1'"
		#echo "Parsing: '$FILE' ($COM) => $OUT"
		ESC='\\\\'

		# cd into the output directory, modify path to not grab a bunch of stuff
		# add /bin and /usr/bin to give the shell most of the commands people expect
		(echo "cd '$OUT' ; PATH='$DIR:/bin:/usr/bin'" ;
		cat "$FILE" |
		# get lines that start with commands or entry dates
		grep -E "^(${ENTRY_SEPERATOR}|!)" |
		awk "$SCRIPT" |
		#grep -E "^!" |
		# rewrite commands to remove meta characters
		sed 's_^![^ ]* \+__' |
		# rewrite \ to multiple so that it gets to the shell properly
		sed 's_\\_\\\\\\\\_g' |
		# rewrite line to escape characters for shell
		sed "s_\([!@#$%^&*(){}'/\"]\)_$ESC\1_g" |
		sed "s_\[_$ESC[_g" |
		sed "s_\]_$ESC]_g" |
		# unfortunately there is not a very nice way to escape '\' characters,
		# they are kind of eaten by xargs. 
		# run the commands one at a time with their arguments
		xargs --max-lines=1 $INTERACT -I '{}' -- "$ECHO" "$COM/{}") |
		# and send them to a shell
		sh
	else
		echo "Not found: $FILE" >> /dev/stderr
	fi
}

function parse-dir(){
	if [ -d "$1" ]; then
		echo "$1"
	else
		usage >> /dev/stderr
		exit 1
	fi
}

#program start

if [ $# -lt 1 ]; then
	usage
	exit 1
fi

while [ $# -gt 0 ]; do
	case "$1" in
	-p)
		INTERACT="-p"
		;;
	-d)
		shift
		DIR=`parse-dir "$1"`
		echo "Changing command directory to $DIR"
		;;
	-o)
		shift
		if [ ! -d "$1" ]; then
			mkdir -p "$1"
		fi
		OUTPUT_DIR="$1"
		echo "Changing output directory to $OUTPUT_DIR"
		;;
	*)
		parse-file "$1"
		;;
	esac

	# shift the args
	shift
done

exit 
