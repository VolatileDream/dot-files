#!/bin/bash

# Global variables
NAME="$0"
DIR='$PATH'
OUTPUT_DIR='.'
ENTRY_SEPERATOR='---------------'
# interactive argument for xargs
INTERACT=''
ECHO_FIRST=0
SHELL=`which sh`
ECHO=`which echo`


function get-commands(){
	# script for doing meta-data command modification
read -d '' SCRIPT <<- EOF
	BEGIN { date=""; }
	/$ENTRY_SEPERATOR/ {
		gsub( /^$ENTRY_SEPERATOR/, "" );
		date = \$0;
	}
	/^![^ ]*d/ {
		# bump all of the arguments and insert
		# the date as the 1st argument
		gsub( /^![^ ]* +[^ ]+/, "& " date );
	}
	/^!/ {
		# remove the ! and meta chars
		gsub( /^![^ ]* +/, "" );
		print \$0 ;
	}
EOF
	cat "$1" |
	# get lines that start with commands or entry dates
	grep -E "^(${ENTRY_SEPERATOR}|!)" |
	# rewrite commands to remove meta characters
	awk "$SCRIPT" | sed 's_^![^ ]* \+__'
}

function usage(){
	echo "Usage: ${NAME} [-p|--path path] [-o|--output output-dir] [-P|--prompt] [-e|--echo] files"
	echo -e "\tParse plain text journal files to generate secondary data sources"
	echo
	echo -e "\t-p, --path  : the PATH to use default=\$PATH"
	echo -e "\t-o, --output: output-dir: specificy the directory to output to. default=."
	echo -e "\t-P, --prompt: get prompted before each command runs."
	echo -e "\t-e, --echo  : write the commands run to stdout."
	echo -e "\tfiles - journal files to parse"
}

function escape-args(){
read -d '' SCRIPT <<- EOF
	{
		printf( "%s", \$1 );
		# group each argument on the line in single quotes (except the first)
		for( i=2 ; i <= NF ; i++ ) {
			printf( "%s\\\\"%s\\\\"", OFS, \$i );
		}
		# print the record seperator
		printf( ORS );
	}
EOF
	awk "$SCRIPT"
}

function null-term-lines(){
	awk '{ printf( "%s%c", $0, 0 ); }'
}

function absolute-path(){
	# check the first character
	if [ "${1:0:1}" = "/" ]; then
		echo "$1"
	else
		echo "${PWD}/${1}"
	fi
}

function parse-file(){
	FILE="$(absolute-path "$1")"
	COM="$DIR"
	OUT="$(absolute-path "$OUTPUT_DIR")"

	if [ -f "$1" ]; then
		echo "Parsing: '$1'"
		#echo "Parsing: '$FILE' ($COM) => $OUT"

		# use a temporary input file to get nice command echoing
		INPUT=`mktemp`
		get-commands "$FILE" >> "$INPUT"
		if [ $ECHO_FIRST -ne 0 ]; then
			cat "$INPUT"
		fi

		# cd into the output directory, modify path to not grab a bunch of stuff
		# add /bin and /usr/bin to give the shell most of the commands people expect
		(echo "cd $OUT ; PATH='$DIR'" ; cat "$INPUT" | escape-args ) |
		sh >> /dev/stderr
		rm "$INPUT"
	else
		echo "Not found: $FILE" >> /dev/stderr
	fi
}

function parse-dir(){
	if [ -d "$1" ]; then
		echo "$1"
	else
		usage >> /dev/stderr
		exit 1
	fi
}

#program start

if [ $# -lt 1 ]; then
	usage
	exit 1
fi

while [ $# -gt 0 ]; do
	case "$1" in
	-e|--echo)
		ECHO_FIRST=1
		;;
	-P|--prompt)
		INTERACT="-p"
		;;
	-p|--path)
		shift
		DIR="$1"
		echo "PATH changed to $DIR"
		;;
	-o|--output)
		shift
		if [ ! -d "$1" ]; then
			mkdir -p "$1"
		fi
		OUTPUT_DIR="$1"
		echo "Changing output directory to $OUTPUT_DIR"
		;;
	*)
		parse-file "$1"
		;;
	esac

	# shift the args
	shift
done

exit 
