#!/usr/bin/env bash

# CONFIG stuff
SEPERATOR="--------------- "
# * also need to make sure that we can take it as a parameter
#   back in with the submit command
# So this ends up being awkward with the number of constraints
DATE_FORMAT="%Y-%m-%d %H:%M:%S.%N"

parse-date(){
	date "+$DATE_FORMAT" "--date=$1"
	return $?
}

submit(){
	local IN="/dev/stdin"
	local DATE=""
	if [ $# -gt 0 ]; then
		case $# in
			1) # date
				DATE="$1" ; shift
			;;
			2) # -f file
				IN="$2" ; shift ; shift
			;;
			3) # date -f file
				DATE="$1" ; shift
				IN="$2" ; shift ; shift
			;;
			*)
				echo "Error in the number of params for submit"
				exit 2
			;;
		esac
	fi

	local date_provided=0
	if [ -z "$DATE" ]; then
		DATE="$(date "+$DATE_FORMAT")"
	else
		# use the provided date
		DATE="$( parse-date "$DATE" )"
		if [ $? -ne 0 ]; then
			exit 2
		fi
		date_provided=1
	fi

	local tmp=`mktemp`
	cat "$IN" | trim > "$tmp"

	cat "$tmp" | chronos append "$ARCHIVE" -t "${DATE}"

	if [ $? -ne 0 ]; then
		if [ $date_provided -ne 0 ]; then
			echo "Bad date provided, is not after the last already added." > /dev/stderr
		else
			echo "Clock skew or future dates were added, current time is not after the last date" > /dev/stderr
		fi

		echo "Last date was: $(chronos last "$ARCHIVE")" > /dev/stderr
		echo "Inserted date is: ${DATE}" > /dev/stderr
		exit 2
	fi

	# put the entry seperator + contents
	(
	 echo -e "${SEPERATOR}${DATE}" ;
	 cat "$tmp" ;
	 echo ;
	) | event-publish "$EVENT"

	rm "$tmp"
}

show(){
	echo "${SEPERATOR}${1}"
	chronos get "$ARCHIVE" "$1"
	echo
}

view(){
	# conveniently we use the fact that chronos provides key listing
	# functionality to find and display matching keys
	for entry in "$@"; do
		
		# Since we get a single entry per line we pipe and use
		# read line to avoid whitespace across the line.
		chronos list "$ARCHIVE" |
		grep -E "^${entry}" | 
		while read key; do
			show "$key" ;
		done
	done
}

peek(){
	local date="$( parse-date "$1" )"
	local EXIT_VALUE=$?

	if [ $EXIT_VALUE -ne 0 ]; then
		exit $EXIT_VALUE
	fi

	chronos get "$ARCHIVE" "$date"

	EXIT_VALUE=$?
	if [ $EXIT_VALUE -eq 0 ]; then
		echo "$date" >> /dev/stderr
	fi

	return $EXIT_VALUE
}

replay(){
	local NL; printf -v NL "\n"
	chronos iterate "$ARCHIVE" "${SEPERATOR}%k${NL}%v${NL}"
}

last-date(){
	local entry="$(chronos last "$ARCHIVE")"
	if [ ! -z "$entry" ]; then
		echo "$entry"
	fi
}

entries(){
	ensure-archive
	chronos list "$ARCHIVE"
	return $?
}

last(){
	ensure-archive
	# just dump the last entry out, and
	# does not print out the entry seperator.
	local last="$(chronos last "$ARCHIVE")"
	local e_val=$?
	if [ $e_val -eq 0 ]; then
		chronos get "$ARCHIVE" "$last"
	fi
	return $e_val
}

ensure-archive(){
	# it's wonderful that chronos takes care of this for us
	chronos init "$ARCHIVE"
	return $?
}


if [ "-a" = "$1" ]; then
	ARCHIVE="$2"
	shift ; shift ; # shift off the archive param
elif lookup .archivist > /dev/null ; then
	ARCHIVE=`lookup .archivist`
else
	# Note that this has to be different than the project-config lookup,
	# because otherwise the user might accidentally run with the wrong location.
	mkdir -p "$HOME/.config/archivist.d/" > /dev/null 2> /dev/null
	ARCHIVE="$HOME/.config/archivist.d/"
fi
command="$1"; shift

if [ "$STR" != "${STR#/}" ]; then
	# relative directory
	ARCHIVE="${PWD}/${ARCHIVE}"
fi
# strip out slashes from the name
EVENT="archivist-$( echo -n $ARCHIVE | sed 's_/_-_g' )-event"

ensure-archive "$ARCHIVE"

case $command in
	submit)
		submit "$@"
	;;
	entries)
		entries
	;;
	peek)
		peek "$@"
	;;
	view)
		view "$@"
	;;
	replay)
		replay
	;;
	date)
		last-date
	;;
	last)
		last
	;;
	sub|subscribe)
		ARG=""
		if [ $# -gt 0 ]; then
			ARG="-n $1"
		fi
		event-subscribe "$EVENT" $ARG
	;;
	*)
read -d '' HELP <<- EOF

archivist is a light weight event bus that supports a few simple operations:

 submit [date-time] [-f file]
 - add a new entry into the bus for the current date-time, or the one specified
 - by default takes stdin, otherwise a file specified

 entries
 - lists the date-time of every single entry in the archive

 view [date-time]+
 - lookup a bunch of entries by date-time
 - simple wildcard-ing:
   - 2004 implies the range '2004-01-01 00:00:00' to '2004-12-31 23:59:59' (inclusive both ends)
   - more fields can be included for the wildcarding to get stricter
 - dumps all entries out to stdout
 - entries are seperated by:
       "-"*15 + " " + \${date} + " " + \${time}

 peek date-time
 - looks for an exact entry by date
 - if no entry is found, exits with non 0 status
 - otherwise the entry is sent to stdout, and the date to stderr

 replay
 - show all entries
 - equivalent to 'view date1 date2 ... daten' where date1-n are all the date-times that have data
 - while equivalent to 'view ...' it is much faster if that is the desired result
 - outputs in the same manner as view

 last
 - retrieves the last event that occured
 - almost equivalent to 'archivist view \$(archivist date)'
    except that this doesn't print the entry seperator.

 sub[scribe] [count]
 - waits for other runs of archivist to update the archive, prints out the
   new updates in the format of the replay/view command

 date
 - retrieves the date-time of the last entry

 as far as archivist is concerned, all events are simple text blobs, and none of them
 is treated any differently than any other. archivist does not support any way to search
 through the events other than by date-time. This is by design, it makes archivist very simple.
 archivist take an optional [-a archive] first parameter to denote the archive being used.
 otherwise the default \$HOME/.archivist/archive is used.
EOF
		echo "$HELP"
	;;
esac

