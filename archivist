#!/usr/bin/env bash

# CONFIG stuff
SEPERATOR="--------------- "
# * due to limitations of kiwi we also want to avoid underscores
# * also need to make sure that we can take it as a parameter
#   back in with the submit command
# So this ends up being awkward with the number of constraints
DATE_FORMAT="%Y-%m-%d %H:%M:%S"

# tiny utility function to print out the seperator and key
seperate(){
	echo "${SEPERATOR}${1}"
}

parse-date(){
	date "+$DATE_FORMAT" "--date=$1"
	return $?
}

submit(){
	IN="/dev/stdin"
	DATE=""
	if [ $# -gt 0 ]; then
		case $# in
			1) # date
				DATE="$1" ; shift
			;;
			2) # -f file
				IN="$2" ; shift ; shift
			;;
			3) # date -f file
				DATE="$1" ; shift
				IN="$2" ; shift ; shift
			;;
			*)
				echo "Error in the number of params for submit"
				exit 2
			;;
		esac
	fi

	date_provided=0
	if [ -z "$DATE" ]; then
		DATE="$(date "+$DATE_FORMAT")"
	else
		# use the provided date
		DATE="$( parse-date "$DATE" )"
		if [ $? -ne 0 ]; then
			exit 2
		fi
		date_provided=1
	fi

	tmp=`mktemp`
	cat "$IN" | trim > "$tmp"

	cat "$tmp" | kiwi "$ARCHIVE" put "$DATE"
	# only update the last pointer if a date wasn't provided
	if [ $date_provided -eq 0 ]; then
		echo "$DATE" | kiwi "$ARCHIVE" put LAST
	fi

	# put the entry seperator + contents
	(seperate "${DATE}" ; cat "$tmp") | event-publish "$EVENT"

	rm "$tmp"
}

show(){
	seperate "$1"
	kiwi "$ARCHIVE" get "$1"
}

view(){
	# conveniently we use the fact that kiwi provides key listing
	# functionality to find and display matching keys
	for entry in "$@"; do
		
		# Since we get a single entry per line we pipe and use
		# read line to avoid whitespace across the line.
		kiwi "$ARCHIVE" list |
		grep "${entry}" | 
		while read key; do
			show "$key" ;
		done
	done
}

peek(){
	local date="$( parse-date "$1" )"
	local EXIT_VALUE=$?

	if [ $EXIT_VALUE -ne 0 ]; then
		exit $EXIT_VALUE
	fi

	matching="$( kiwi "$ARCHIVE" list | grep "$date" )"
	if [ "$matching" = "$date" ]; then
		echo "$date" > /dev/stderr
		kiwi "$ARCHIVE" get "$date" > /dev/stdout
	else
		# that key doesn't exist
		exit 2
	fi
}

replay(){
	# (ab)use the way view works.
	# there should only be 2 types of keys:
	# * LAST
	# * keys matching DATE_FORMAT
	# So we pass something that will only
	#  match the DATE_FORMAT entries.
	view ' '
}

last-date(){
	entry="$(kiwi "$ARCHIVE" get LAST)"
	if [ ! -z "$entry" ]; then
		echo "$entry"
	fi
}

if [ "-a" = "$1" ]; then
	ARCHIVE="$2"
	shift ; shift ; # shift off the archive param
else
	mkdir "$HOME/.archivist" > /dev/null 2> /dev/null
	ARCHIVE="$HOME/.archivist/archive"
fi
command="$1"; shift

# strip out slashes from the name
EVENT="$( echo -n $ARCHIVE | sed 's_/_-_g' )-event"

case $command in
	submit)
		submit "$@"
	;;
	peek)
		peek "$@"
	;;
	view)
		view "$@"
	;;
	replay)
		replay
	;;
	date)
		last-date
	;;
	last)
		# just dump the last entry out, and
		# does not print out the entry seperator.
		last="$(kiwi "$ARCHIVE" get LAST)"
		kiwi "$ARCHIVE" get "$last"
	;;
	sub|subscribe)
		ARG=""
		if [ $# -gt 0 ]; then
			ARG="-n $1"
		fi
		event-subscribe "$EVENT" $ARG
	;;
	*)
read -d '' HELP <<- EOF

archivist is a light weight event bus that supports a few simple operations:

 submit [date-time] [-f file]
 - add a new entry into the bus for the current date-time, or the one specified
 - by default takes stdin, otherwise a file specified
 - specifying a time does NOT update the value retrieved by 'last'

 view [date-time]+
 - lookup a bunch of entries by date-time
 - simple wildcard-ing:
   - 2004 implies the range '2004-01-01 00:00:00' to '2004-12-31 23:59:59' (inclusive both ends)
   - more fields can be included for the wildcarding to get stricter
 - dumps all entries out to stdout
 - entries are seperated by:
       "-"*15 + " " + \${date} + " " + \${time}

 peek date-time
 - looks for an exact entry by date
 - if no entry is found, exits with non 0 status
 - otherwise the entry is sent to stdout, and the date to stderr

 replay
 - show all entries
 - equivalent to 'view date1 date2 ... daten' where date1-n are all the date-times that have data
 - while equivalent to 'view ...' it is much faster if that is the desired result
 - outputs in the same manner as view

 last
 - retrieves the last event that occured
 - almost equivalent to 'archivist view \$(archivist date)'
    except that this doesn't print the entry seperator.

 sub[scribe] [count]
 - waits for other runs of archivist to update the archive, prints out the
   new updates in the format of the replay/view command

 date
 - retrieves the date-time of the last entry

 as far as archivist is concerned, all events are simple text blobs, and none of them
 is treated any differently than any other. archivist does not support any way to search
 through the events other than by date-time. This is by design, it makes archivist very simple.
 archivist take an optional [-a archive] first parameter to denote the archive being used.
 otherwise the default \$HOME/.archivist/archive is used.
EOF
		echo "$HELP"
	;;
esac

