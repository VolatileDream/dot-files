#!/usr/bin/env bash

if [ $# -ne 1 ]; then
	echo "Usage: $0 event"
	echo "event-publish is one of two parts of a simple command line pub/sub mechanism"
	echo
	echo "It takes 1 parameter, which is the event 'name' that is wanted."
	echo "The event name must be a legal file name, and will get created under /tmp."
	echo "It takes it's data from stdin, and sends it to a temporary file."
	echo "And then notifies all tasks that have setup to recieve notifications."
	exit 1
fi

DIR_BASE=/tmp/events
FILE_BASE="$1" ; shift

# make the file path absolute, off /tmp
if [ "${FILE_BASE:0:1}" != "/" ]; then
	mkdir "$DIR_BASE" > /dev/null 2> /dev/null
	FILE_BASE="${DIR_BASE}/${FILE_BASE}"
else
	echo "Warning: Event is already has an absolute path."
	echo "EVENT: $FILE_BASE"
fi

# create a temporary file and put all of stdin into it. this is desirable
# because we might be writing to a bunch of different files.
tmp=`mktemp`
cat - > "$tmp"

for file in "$FILE_BASE"* ; do
	# it needs to be a pipe file
	if [ -p "$file" ]; then
		# If we start writting to a pipe when it has not been opened
		# for reading, and it then gets deleted, there is no way to
		# recover.

		# A process might exit and delete it's pipe after we've
		# starting writing to it (having been opened for read), this is
		# ok. The kernel will error the write(2) call with EPIPE. cat
		# handles this correctly.

		cat "$tmp" >> "$file"
		echo "Notified: $file"
	fi
done

rm "$tmp"

