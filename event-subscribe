#!/usr/bin/env bash

if [ $# -ne 1 -a $# -ne 3 ]; then
	echo "Usage: $0 event [-n count]"
	echo "event-subscribe is one of two parts of a simple command line pub/sub mechanism"
	echo
	echo "It takes 1 parameter, which is the event "name" that is wanted."
	echo "The event name must be a legal file name, and will get created under /tmp."
	echo "It prints events that arrive to stdout, defaulting to a continuous listening."
	echo "Optionally provided a count for the number of events to receive."
	exit 1
fi

DIR_BASE=/tmp/events
FILE_BASE="$1" ; shift

# make the file path absolute, off /tmp
if [ "${FILE_BASE:0:1}" != "/" ]; then
	mkdir "$DIR_BASE" > /dev/null 2> /dev/null
	FILE_BASE="${DIR_BASE}/${FILE_BASE}"
else
	echo "Warning: Event is already has an absolute path."
	echo "EVENT: $FILE_BASE"
	echo "This should be avoided because it has the possibility"
	echo " of creating PIPE files that don't get cleaned up"
	echo " across system shutdown."
fi

# check if we're supposed to continue
if [ "$1" = "-n" ]; then
	COUNT=$2
else
	COUNT=-1
fi

cleanup(){
	rm "$FILE"
	exit $?
}

# attach our pid to the event name
FILE="${FILE_BASE}-$$"

# trap control-c to cleanup
trap cleanup SIGINT

mkfifo "$FILE"

while true; do

	# last event
	if [ $COUNT -eq 0 ]; then
		break
	elif [ $COUNT -gt 0 ]; then
		COUNT=$((COUNT-1))
	fi

	cat "$FILE"

done

# run cleanup
cleanup

