#!/usr/bin/env python3

import argparse
from pathlib import Path
import sys

class Deployer:
  slots = ["from_root", "to_root", "dry_run"]
  def __init__(self, deploy_from_root, deploy_to_root, dry_run=True):
    self.from_root = Path(deploy_from_root or Path()).resolve()
    self.to_root = Path(deploy_to_root or Path().home()).resolve()
    self.dry_run = dry_run

  def mapping(self, line):
    try:
      source, target = line.strip().split(" -> ", 1)

      # Work around absolute file weirdness in pathlib
      if source.startswith("/"):
        source = "." + source
      if target.startswith("/"):
        target = "." + target

      if source.endswith("/") and not target.endswith("/"):
        raise Exception("Can not link directory to file: {}".format(line))

      # Can link file to directory, implies the name is kept
      if not source.endswith("/") and target.endswith("/"):
        *_, src_name = source.rsplit("/", 1)
        target = target + src_name

      self.link(source, target)

    except ValueError as e:
      raise Exception("Bad line, needs to contain ' -> ': {}".format(line)) from e

  def link(self, source, target):
    source = self.from_root.joinpath(source)
    dest = self.to_root.joinpath(target)
    if not source.exists() and not self.dry_run:
      raise Exception("Source file does not exist: {}".format(source))

    # Make sure the parent directory exists.
    if not self.dry_run:
      dest.parent.mkdir(parents=True, exist_ok=True)

    if dest.exists():
      if not dest.is_symlink():
        print("Removing {}".format(dest))
        if not self.dry_run:
          dest.unlink()
      elif not dest.readlink().samefile(source):
        print("Bad link at {} points to {}".format(dest, dest.readlink()))
      else:
        print("Already linked {}".format(dest))
        return

    print("Linking {} to {}".format(dest, source))
    if not self.dry_run:
      dest.symlink_to(source, target_is_directory=target.endswith("/"))

def parser():
  p = argparse.ArgumentParser()

  p.add_argument("-r", "--root", help="Root directory to deploy to.")
  p.add_argument("-c", "--config", help="Root directory of the config files.")
  p.add_argument("--dry-run", help="List changes that would be made.", default=False, action='store_true')
  p.add_argument("file", nargs="*", help="Configuration files to consume (default: stdin)")

  return p


def main():
  args = parser().parse_args()

  files = [open(f, "r") for f in args.file]
  if not files:
    files = [sys.stdin]

  d = Deployer(args.config, args.root, dry_run=args.dry_run)
  for f in files:
    for line in f:
      line = line.strip()
      if not line:
        continue
      d.mapping(line)


if __name__ == "__main__":
  main()
