#!/bin/bash

# Global variables
NAME="$0"
USE_PATH='$PATH'
OUTPUT_DIR='.'
ENTRY_SEPERATOR="$(journal config journal entry-seperator)"
# interactive argument for xargs
INTERACT=''
ECHO_FIRST=0
SHELL=`which sh`
ECHO=`which echo`

VERBOSE=""
verbose(){
	if [ ! -z "$VERBOSE" ]; then
		echo
	fi
}

read -d '' GET_COMMANDS_SCRIPT <<- EOF
	BEGIN { date=""; }
	/$ENTRY_SEPERATOR/ {
		gsub( /^$ENTRY_SEPERATOR/, "" );
		date = \$0;
	}
	/^![^ ]*d/ {
		# bump all of the arguments and insert
		# the date as the 1st argument
		gsub( /^![^ ]* +[^ ]+/, "& " date );
	}
	/^!/ {
		# remove the ! and meta chars
		gsub( /^![^ ]* +/, "" );
		print \$0 ;
	}
EOF
function get-commands(){
	# script for doing meta-data command modification
	cat "$1" |
	# get lines that start with commands or entry dates
	grep -E "^(${ENTRY_SEPERATOR}|!)" |
	# rewrite commands to remove meta characters
	awk "$GET_COMMANDS_SCRIPT" | sed 's_^![^ ]* \+__'
}

function usage(){
	echo "Usage: ${NAME} [options] files"
	echo -e "\tParse plain text journal files to generate secondary data sources"
	echo
	echo -e "\t-p, --path  : append to the front of \$PATH."
	echo -e "\t-o, --output: output-dir: specificy the directory to output to. default=."
	echo -e "\t-P, --prompt: get prompted before each command runs."
	echo -e "\t-e, --echo  : write the commands run to stdout."
	echo -e "\t-s, --stdin : take input from standard input."
	echo -e "\tfiles - journal files to parse"
}

function absolute-path(){
	# check the first character
	if [ "${1:0:1}" = "/" ]; then
		echo "$1"
	else
		echo "${PWD}/${1}"
	fi
}

read -d '' ESCAPE_ARG_SCRIPT <<- EOF
	{
		printf( "%s", \$1 );
		# group each argument on the line in single quotes (except the first)
		for( i=2 ; i <= NF ; i++ ) {
			printf( "%s\\\\"%s\\\\"", OFS, \$i );
		}
		# print the record seperator
		printf( ORS );
	}
EOF
function exec-shell(){
	# INPUT = $1

	# cd into the output directory, modify path to not grab a bunch of stuff
	(echo "cd '$OUTPUT_DIR' ; PATH='$USE_PATH:$PATH'" ; cat "$1" | awk "$ESCAPE_ARG_SCRIPT" ) |
	sh >> /dev/stderr
}

function parse-file(){
	if [ $# -eq 0 ];then
		FILE="/proc/$$/fd/0"
	else
		FILE="$(absolute-path "$1")"
	fi

	if [ -f "$FILE" -o -e "$FILE" ]; then
		verbose "$1"

		# use a temporary input file to get nice command echoing
		INPUT=`mktemp`
		get-commands "$FILE" >> "$INPUT"
		if [ $ECHO_FIRST -ne 0 ]; then
			cat "$INPUT"
		fi

		exec-shell "$INPUT"

		rm "$INPUT"
	else
		echo "Not found: $FILE" >> /dev/stderr
	fi
}

function parse-dir(){
	if [ -d "$1" ]; then
		echo "$1"
	else
		usage >> /dev/stderr
		exit 1
	fi
}

#program start

if [ $# -lt 1 ]; then
	usage
	exit 1
fi

while [ $# -gt 0 ]; do
	case "$1" in
	-v|--verbose)
		VERBOSE="1"
		;;
	-e|--echo)
		ECHO_FIRST=1
		;;
	-P|--prompt)
		INTERACT="-p"
		;;
	-p|--path)
		shift
		USE_PATH="$1"
		verbose "PATH changed to $USE_PATH"
		;;
	-o|--output)
		shift
		if [ ! -d "$1" ]; then
			mkdir -p "$1"
		fi
		OUTPUT_DIR="$(absolute-path "$1")"
		verbose "Changing output directory to $OUTPUT_DIR"
		;;
	-s|--stdin)
		parse-file # implicitly stdin
		;;
	*)
		parse-file "$1"
		;;
	esac

	# shift the args
	shift
done

exit 
